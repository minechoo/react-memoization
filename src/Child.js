import { memo } from 'react';
//props로 전달되는 값이 참조형 자료일때 참조링크값을 비교하는 것이아닌 참조되고 있는 원본 데이터가 같은지를 비교
import { isEqual } from 'lodash';

function Child(props) {
	console.log('child');
	return (
		<div>
			<h1>Child</h1>
		</div>
	);
}

export default memo(Child);

/*
  메모이제이션
  - 특정 값을 강제로 메모리에 할당해서 값을 재활용 (속도가 빨라짐)
  - 메모이제이션을 많이 할수록 메모리점유율을 강제로 늘려서 속도를 증가
  - 자바스크립트엔진은 garbage collection (안쓰는 메모리를 정기적으로 제거해서 메모리 최적화)
  - 메모이제이션된 요소는 가비지 컬렉션에서 제외됨

  부모 컴포넌트가 재호출되면 자식 컴포넌트는 변경되는 내용이 없음에도 불구하고 무조건 재호출 (불필요한 함수 호출 발생)

  memo - 특정 컴포넌트 자체를 메모이제이션해서 부모컴포넌트가 재랜더링 되더라도 자식 컴포넌트를 매번 재랜더링하는 것이 아닌 이전 렌더링된 결과값을 재활용 (불필요한 재랜더링 방지)

  hoc(high order compoent) :함수로 인수로 함수를 전달해서 새로운 함수를 반환하는 형태

  - 자식컴포넌트가 memo로 메모이제이션되었다 하더라도 prop값이 전달되면 memoization이 풀림
  - 자식 요소에 props전달되지 않는 값이 부모 컴포넌트에서 변경되면 그때는 자식컴포넌트의 메모이제이션이 유지됨

  -만약 prop으로 참조형 자료가 전달되면 부모에서 해당값을 변경하지 않더라도 부모컴포넌트가 재랜더링되면 자식컴포넌트의 메모이제이션이 풀리면서 재호출 발생

  - 위와 같은 현상 발생이유 - 참조형 자료는 메모리에 해당 값 자체가 할당되는 것이 아닌 참조 링크가 할당되기 때문에 부모컴포넌트가 재호출일어나면 참조링크가 계속 변경되고 자식 컴포넌트 입장에서는 매번 다른 값이 전달되므로 메모이제이션을 해제
  - 해결방법 : lodash의 isEqual을 이용해서 참조링크가 아닌 참조되는 원본 데이터값을 비교해서 해결
*/
